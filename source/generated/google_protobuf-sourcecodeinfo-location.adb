--  begin read only
--  Generated by the protocol buffer compiler. DO NOT EDIT!
--  source: google/protobuf/descriptor.proto
--
--  ----------------------------------------------------------------------
pragma Warnings (Off);
pragma Ada_2012;
with Google.Protobuf.Message;
with Google.Protobuf.Wire_Format;
with Google.Protobuf.IO.Coded_Output_Stream;
with Google.Protobuf.IO.Coded_Input_Stream;
with Google.Protobuf.Generated_Message_Utilities;
with Ada.Streams.Stream_IO;
with Ada.Containers.Vectors;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
with Interfaces;

package body Google_Protobuf.SourceCodeInfo.Location is
  ---------------------------------------------------------------------------
  --    Inherited functions and procedures from Google.Protobuf.Message    --
  ---------------------------------------------------------------------------

  procedure Clear (The_Message : in out Google_Protobuf.SourceCodeInfo.Location.Instance) is
  begin
    if (The_Message.Has_Bits (2 / 32) and Google.Protobuf.Wire_Format.Shift_Left (16#FF#, 2 mod 32)) /= 0 then
      if The_Message.Has_Leading_Comments then
        The_Message.Clear_Has_Leading_Comments;
        declare
           procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
        begin
           if The_Message.Leading_Comments /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
              Free (The_Message.Leading_Comments);
           end if;
        end;
        The_Message.Leading_Comments := Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access;
      end if;
      if The_Message.Has_Trailing_Comments then
        The_Message.Clear_Has_Trailing_Comments;
        declare
           procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
        begin
           if The_Message.Trailing_Comments /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
              Free (The_Message.Trailing_Comments);
           end if;
        end;
        The_Message.Trailing_Comments := Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access;
      end if;
    end if;
    The_Message.Path.Clear;
    The_Message.Span.Clear;
    declare
       Temp : Google.Protobuf.Wire_Format.PB_String_Access;
       procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
    begin
       for E of The_Message.Leading_Detached_Comments loop
          Temp := E;
          Free (Temp);
       end loop;
    end;
    The_Message.Leading_Detached_Comments.Clear;

    The_Message.Has_Bits := (others => 0);
  end Clear;

  procedure Copy (To   : in out Google_Protobuf.SourceCodeInfo.Location.Instance;
                  From : in Google_Protobuf.SourceCodeInfo.Location.Instance) is
  begin
     To.Clear;
     To.Merge (From);
  end Copy;

  function Get_Type_Name (The_Message : in Google_Protobuf.SourceCodeInfo.Location.Instance) return Google.Protobuf.Wire_Format.PB_String is
  begin
     return "google.protobuf.SourceCodeInfo.Location";
  end Get_Type_Name;

  function Is_Initialized (The_Message : in Google_Protobuf.SourceCodeInfo.Location.Instance) return Boolean is
  begin
    return True;
  end Is_Initialized;

  procedure Merge (To : in out Google_Protobuf.SourceCodeInfo.Location.Instance; From : in Google_Protobuf.SourceCodeInfo.Location.Instance) is
  begin
    To.Path.Append(From.Path);
    To.Span.Append(From.Span);
    for E of From.Leading_Detached_Comments loop
       To.Leading_Detached_Comments.Append (new Google.Protobuf.Wire_Format.PB_String'(E.all));
    end loop;
    if (From.Has_Bits (2 / 32) and Google.Protobuf.Wire_Format.Shift_Left (16#FF#, 2 mod 32)) /= 0 then
      -- optional string leading_comments = 3;
      if From.Has_Leading_Comments then
        To.Set_Leading_Comments(From.Get_Leading_Comments);
      end if;
      -- optional string trailing_comments = 4;
      if From.Has_Trailing_Comments then
        To.Set_Trailing_Comments(From.Get_Trailing_Comments);
      end if;
    end if;
  end Merge;

  function Byte_Size (The_Message : in out Google_Protobuf.SourceCodeInfo.Location.Instance) return Google.Protobuf.Wire_Format.PB_Object_Size is
     Total_Size : Google.Protobuf.Wire_Format.PB_Object_Size := 0;
  begin
    if (The_Message.Has_Bits (2 / 32) and Google.Protobuf.Wire_Format.Shift_Left (16#FF#, 2 mod 32)) /= 0 then
      -- optional string leading_comments = 3;
      if The_Message.Has_Leading_Comments then
        Total_Size := Total_Size + 1 + Google.Protobuf.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.Leading_Comments.all);
      end if;
      -- optional string trailing_comments = 4;
      if The_Message.Has_Trailing_Comments then
        Total_Size := Total_Size + 1 + Google.Protobuf.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.Trailing_Comments.all);
      end if;
    end if;
    -- repeated int32 path = 1 [packed = true];
    declare
       Data_Size : Google.Protobuf.Wire_Format.PB_Object_Size := 0;
    begin
       for E of The_Message.Path loop
          Data_Size := Data_Size +  Google.Protobuf.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (E);
       end loop;
       if Data_Size > 0 then
          Total_Size := Total_Size + 1 + Google.Protobuf.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (Google.Protobuf.Wire_Format.PB_Int32 (Data_Size));
       end if;
       The_Message.Path_Cached_Byte_Size := Data_Size;
       Total_Size := Total_Size + Data_Size;
    end;

    -- repeated int32 span = 2 [packed = true];
    declare
       Data_Size : Google.Protobuf.Wire_Format.PB_Object_Size := 0;
    begin
       for E of The_Message.Span loop
          Data_Size := Data_Size +  Google.Protobuf.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (E);
       end loop;
       if Data_Size > 0 then
          Total_Size := Total_Size + 1 + Google.Protobuf.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (Google.Protobuf.Wire_Format.PB_Int32 (Data_Size));
       end if;
       The_Message.Span_Cached_Byte_Size := Data_Size;
       Total_Size := Total_Size + Data_Size;
    end;

    -- repeated string leading_detached_comments = 6;
    Total_Size := Total_Size + 1 * The_Message.Leading_Detached_Comments_Size;
    for E of The_Message.Leading_Detached_Comments loop
       Total_Size := Total_Size + Google.Protobuf.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (E.all);
    end loop;

    The_Message.Cached_Size := Total_Size;
    return Total_Size;
  end Byte_Size;

  procedure Serialize_With_Cached_Sizes
     (The_Message   : in Google_Protobuf.SourceCodeInfo.Location.Instance;
      The_Coded_Output_Stream : in Google.Protobuf.IO.Coded_Output_Stream.Instance) is
  begin
    -- repeated int32 path = 1 [packed = true];
    if The_Message.Path_Size > 0 then
       The_Coded_Output_Stream.Write_Tag (1, Google.Protobuf.Wire_Format.LENGTH_DELIMITED);
       The_Coded_Output_Stream.Write_Raw_Varint_32 (Google.Protobuf.Wire_Format.PB_UInt32(The_Message.Path_Cached_Byte_Size));
    end if;
    for E of The_Message.Path loop
       The_Coded_Output_Stream.Write_Integer_32_No_Tag (E);
    end loop;
    -- repeated int32 span = 2 [packed = true];
    if The_Message.Span_Size > 0 then
       The_Coded_Output_Stream.Write_Tag (2, Google.Protobuf.Wire_Format.LENGTH_DELIMITED);
       The_Coded_Output_Stream.Write_Raw_Varint_32 (Google.Protobuf.Wire_Format.PB_UInt32(The_Message.Span_Cached_Byte_Size));
    end if;
    for E of The_Message.Span loop
       The_Coded_Output_Stream.Write_Integer_32_No_Tag (E);
    end loop;
    -- optional string leading_comments = 3;
    if The_Message.Has_Leading_Comments then
      The_Coded_Output_Stream.Write_String (3, The_Message.Leading_Comments.all);
    end if;
    -- optional string trailing_comments = 4;
    if The_Message.Has_Trailing_Comments then
      The_Coded_Output_Stream.Write_String (4, The_Message.Trailing_Comments.all);
    end if;
    -- repeated string leading_detached_comments = 6;
    for E of The_Message.Leading_Detached_Comments loop
       The_Coded_Output_Stream.Write_String (6, E.all);
    end loop;
  end Serialize_With_Cached_Sizes;

  procedure Merge_Partial_From_Coded_Input_Stream
     (The_Message   : in out Google_Protobuf.SourceCodeInfo.Location.Instance;
      The_Coded_Input_Stream : in out Google.Protobuf.IO.Coded_Input_Stream.Instance) is

     Tag : Google.Protobuf.Wire_Format.PB_UInt32;
  begin
    Tag := The_Coded_Input_Stream.Read_Tag;
    while Tag /= 0 loop
      case Google.Protobuf.Wire_Format.Get_Tag_Field_Number (Tag) is
      -- repeated int32 path = 1 [packed = true];
      when 1 =>
        if Google.Protobuf.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Google.Protobuf.Wire_Format.LENGTH_DELIMITED then
          declare
             use type Ada.Streams.Stream_Element_Offset;
             Length : Google.Protobuf.Wire_Format.PB_UInt32 :=  The_Coded_Input_Stream.Read_Raw_Varint_32;
             Limit  : Ada.Streams.Stream_Element_Offset := The_Coded_Input_Stream.Push_Limit (Ada.Streams.Stream_Element_Offset(Length));
          begin
             while The_Coded_Input_Stream.Get_Bytes_Until_Limit > 0 loop
                The_Message.Path.append (The_Coded_Input_Stream.Read_Integer_32);
             end loop;
             The_Coded_Input_Stream.Pop_Limit (Limit);
          end;
        end if;
      -- repeated int32 span = 2 [packed = true];
      when 2 =>
        if Google.Protobuf.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Google.Protobuf.Wire_Format.LENGTH_DELIMITED then
          declare
             use type Ada.Streams.Stream_Element_Offset;
             Length : Google.Protobuf.Wire_Format.PB_UInt32 :=  The_Coded_Input_Stream.Read_Raw_Varint_32;
             Limit  : Ada.Streams.Stream_Element_Offset := The_Coded_Input_Stream.Push_Limit (Ada.Streams.Stream_Element_Offset(Length));
          begin
             while The_Coded_Input_Stream.Get_Bytes_Until_Limit > 0 loop
                The_Message.Span.append (The_Coded_Input_Stream.Read_Integer_32);
             end loop;
             The_Coded_Input_Stream.Pop_Limit (Limit);
          end;
        end if;
      -- optional string leading_comments = 3;
      when 3 =>
        if Google.Protobuf.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Google.Protobuf.Wire_Format.LENGTH_DELIMITED then
          declare
             procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
          begin
             if The_Message.Leading_Comments /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
                Free (The_Message.Leading_Comments);
             end if;
          end;
          The_Message.Set_Has_Leading_Comments;
          The_Message.Leading_Comments := The_Coded_Input_Stream.Read_String;
        end if;
      -- optional string trailing_comments = 4;
      when 4 =>
        if Google.Protobuf.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Google.Protobuf.Wire_Format.LENGTH_DELIMITED then
          declare
             procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
          begin
             if The_Message.Trailing_Comments /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
                Free (The_Message.Trailing_Comments);
             end if;
          end;
          The_Message.Set_Has_Trailing_Comments;
          The_Message.Trailing_Comments := The_Coded_Input_Stream.Read_String;
        end if;
      -- repeated string leading_detached_comments = 6;
      when 6 =>
        if Google.Protobuf.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Google.Protobuf.Wire_Format.LENGTH_DELIMITED then
          The_Message.Leading_Detached_Comments.Append (The_Coded_Input_Stream.Read_String);
        end if;
      when others =>
        declare
           Dummy : Google.Protobuf.Wire_Format.PB_Bool with Unreferenced;
        begin
           Dummy := The_Coded_Input_Stream.Skip_Field (Tag);
           return;
        end;
      end case;
      Tag := The_Coded_Input_Stream.Read_Tag;
    end loop;
  end Merge_Partial_From_Coded_Input_Stream;

  function Get_Cached_Size
     (The_Message : in Google_Protobuf.SourceCodeInfo.Location.Instance) return Google.Protobuf.Wire_Format.PB_Object_Size is
  begin
     return The_Message.Cached_Size;
  end Get_Cached_Size;

  overriding
  procedure Finalize (The_Message : in out Google_Protobuf.SourceCodeInfo.Location.Instance) is
  begin
    declare
       procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
    begin
       if The_Message.Leading_Comments /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.Leading_Comments);
       end if;
    end;
    declare
       procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
    begin
       if The_Message.Trailing_Comments /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.Trailing_Comments);
       end if;
    end;
    declare
       Temp : Google.Protobuf.Wire_Format.PB_String_Access;
       procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
    begin
       for E of The_Message.Leading_Detached_Comments loop
          Temp := E;
          Free (Temp);
       end loop;
    end;
    The_Message.Leading_Detached_Comments.Clear;

  end Finalize;

  ---------------------------------------------------------------------------
  --                  Field accessor definitions                           --
  ---------------------------------------------------------------------------

  -- repeated int32 path = 1 [packed = true];
  function Path_Size
     (The_Message : in SourceCodeInfo.Location.Instance) return Google.Protobuf.Wire_Format.PB_Object_Size is
  begin
     return Google.Protobuf.Wire_Format.PB_Object_Size (The_Message.Path.Length);
  end Path_Size;

  procedure Clear_Path
     (The_Message : in out SourceCodeInfo.Location.Instance) is
  begin
    The_Message.Path.Clear;
  end Clear_Path;

  function Get_Path
     (The_Message : in SourceCodeInfo.Location.Instance;
      Index       : in Google.Protobuf.Wire_Format.PB_Object_Size) return Google.Protobuf.Wire_Format.PB_Int32 is
  begin
     return The_Message.Path.Element (Index);
  end Get_Path;

  procedure Set_Path
     (The_Message : in out SourceCodeInfo.Location.Instance;
      Index       : in Google.Protobuf.Wire_Format.PB_Object_Size;
      Value       : in Google.Protobuf.Wire_Format.PB_Int32) is
  begin
     The_Message.Path.Replace_Element (Index, Value);
  end Set_Path;

  procedure Add_Path
     (The_Message : in out SourceCodeInfo.Location.Instance;
      Value       : in Google.Protobuf.Wire_Format.PB_Int32) is
  begin
     The_Message.Path.Append (Value);
  end Add_Path;

  -- repeated int32 span = 2 [packed = true];
  function Span_Size
     (The_Message : in SourceCodeInfo.Location.Instance) return Google.Protobuf.Wire_Format.PB_Object_Size is
  begin
     return Google.Protobuf.Wire_Format.PB_Object_Size (The_Message.Span.Length);
  end Span_Size;

  procedure Clear_Span
     (The_Message : in out SourceCodeInfo.Location.Instance) is
  begin
    The_Message.Span.Clear;
  end Clear_Span;

  function Get_Span
     (The_Message : in SourceCodeInfo.Location.Instance;
      Index       : in Google.Protobuf.Wire_Format.PB_Object_Size) return Google.Protobuf.Wire_Format.PB_Int32 is
  begin
     return The_Message.Span.Element (Index);
  end Get_Span;

  procedure Set_Span
     (The_Message : in out SourceCodeInfo.Location.Instance;
      Index       : in Google.Protobuf.Wire_Format.PB_Object_Size;
      Value       : in Google.Protobuf.Wire_Format.PB_Int32) is
  begin
     The_Message.Span.Replace_Element (Index, Value);
  end Set_Span;

  procedure Add_Span
     (The_Message : in out SourceCodeInfo.Location.Instance;
      Value       : in Google.Protobuf.Wire_Format.PB_Int32) is
  begin
     The_Message.Span.Append (Value);
  end Add_Span;

  -- optional string leading_comments = 3;
  function Has_Leading_Comments
     (The_Message : in SourceCodeInfo.Location.Instance) return Boolean is
  begin
     return (The_Message.Has_Bits(0) and 16#00000004#) /= 0;
  end Has_Leading_Comments;

  procedure Set_Has_Leading_Comments
     (The_Message : in out SourceCodeInfo.Location.Instance) is
  begin
     The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000004#;
  end Set_Has_Leading_Comments;

  procedure Clear_Has_Leading_Comments
     (The_Message : in out SourceCodeInfo.Location.Instance) is
  begin
     The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000004#);
  end Clear_Has_Leading_Comments;

  procedure Clear_Leading_Comments
     (The_Message : in out SourceCodeInfo.Location.Instance) is
  begin
    The_Message.Clear_Has_Leading_Comments;
    declare
       procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
    begin
       if The_Message.Leading_Comments /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.Leading_Comments);
       end if;
    end;
    The_Message.Leading_Comments := Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access;
    The_Message.Clear_Has_Leading_Comments;
  end Clear_Leading_Comments;

  function Get_Leading_Comments
     (The_Message : in SourceCodeInfo.Location.Instance) return Google.Protobuf.Wire_Format.PB_String is
  begin
     return The_Message.Leading_Comments.all;
  end Get_Leading_Comments;

  function Get_Leading_Comments
     (The_Message : in out SourceCodeInfo.Location.Instance;
     Size        : in Integer := -1) return Google.Protobuf.Wire_Format.PB_String_Access is
  begin
     The_Message.Set_Has_Leading_Comments;
     if Size >= 0 then
  declare
     procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
  begin
     if The_Message.Leading_Comments /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
        Free (The_Message.Leading_Comments);
     end if;
  end;
         The_Message.Leading_Comments := new Google.Protobuf.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
         return The_Message.Leading_Comments;
     end if;

     if The_Message.Leading_Comments = Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
        The_Message.Leading_Comments := new String'(Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING);
      end if;
      return The_Message.Leading_Comments;
  end Get_Leading_Comments;

  procedure Set_Leading_Comments
     (The_Message : in out SourceCodeInfo.Location.Instance;
      Value       : in Google.Protobuf.Wire_Format.PB_String) is
  begin
     The_Message.Set_Has_Leading_Comments;
     if The_Message.Leading_Comments /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access and then Value'Length = The_Message.Leading_Comments.all'Length then
        The_Message.Leading_Comments.all := Value;
     else
  declare
     procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
  begin
     if The_Message.Leading_Comments /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
        Free (The_Message.Leading_Comments);
     end if;
  end;
        The_Message.Leading_Comments := new Google.Protobuf.Wire_Format.PB_String'(Value);
     end if;
  end Set_Leading_Comments;

  function Release_Leading_Comments
     (The_Message : in out SourceCodeInfo.Location.Instance) return Google.Protobuf.Wire_Format.PB_String_Access is
  begin
     The_Message.Clear_Has_Leading_Comments;
     if The_Message.Leading_Comments = Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
        return null;
     else
        declare
           Temp : Google.Protobuf.Wire_Format.PB_String_Access := The_Message.Leading_Comments;
        begin
           The_Message.Leading_Comments := Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access;
           return Temp;
        end;
     end if;
  end Release_Leading_Comments;

  -- optional string trailing_comments = 4;
  function Has_Trailing_Comments
     (The_Message : in SourceCodeInfo.Location.Instance) return Boolean is
  begin
     return (The_Message.Has_Bits(0) and 16#00000008#) /= 0;
  end Has_Trailing_Comments;

  procedure Set_Has_Trailing_Comments
     (The_Message : in out SourceCodeInfo.Location.Instance) is
  begin
     The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000008#;
  end Set_Has_Trailing_Comments;

  procedure Clear_Has_Trailing_Comments
     (The_Message : in out SourceCodeInfo.Location.Instance) is
  begin
     The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000008#);
  end Clear_Has_Trailing_Comments;

  procedure Clear_Trailing_Comments
     (The_Message : in out SourceCodeInfo.Location.Instance) is
  begin
    The_Message.Clear_Has_Trailing_Comments;
    declare
       procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
    begin
       if The_Message.Trailing_Comments /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.Trailing_Comments);
       end if;
    end;
    The_Message.Trailing_Comments := Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access;
    The_Message.Clear_Has_Trailing_Comments;
  end Clear_Trailing_Comments;

  function Get_Trailing_Comments
     (The_Message : in SourceCodeInfo.Location.Instance) return Google.Protobuf.Wire_Format.PB_String is
  begin
     return The_Message.Trailing_Comments.all;
  end Get_Trailing_Comments;

  function Get_Trailing_Comments
     (The_Message : in out SourceCodeInfo.Location.Instance;
     Size        : in Integer := -1) return Google.Protobuf.Wire_Format.PB_String_Access is
  begin
     The_Message.Set_Has_Trailing_Comments;
     if Size >= 0 then
  declare
     procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
  begin
     if The_Message.Trailing_Comments /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
        Free (The_Message.Trailing_Comments);
     end if;
  end;
         The_Message.Trailing_Comments := new Google.Protobuf.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
         return The_Message.Trailing_Comments;
     end if;

     if The_Message.Trailing_Comments = Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
        The_Message.Trailing_Comments := new String'(Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING);
      end if;
      return The_Message.Trailing_Comments;
  end Get_Trailing_Comments;

  procedure Set_Trailing_Comments
     (The_Message : in out SourceCodeInfo.Location.Instance;
      Value       : in Google.Protobuf.Wire_Format.PB_String) is
  begin
     The_Message.Set_Has_Trailing_Comments;
     if The_Message.Trailing_Comments /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access and then Value'Length = The_Message.Trailing_Comments.all'Length then
        The_Message.Trailing_Comments.all := Value;
     else
  declare
     procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
  begin
     if The_Message.Trailing_Comments /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
        Free (The_Message.Trailing_Comments);
     end if;
  end;
        The_Message.Trailing_Comments := new Google.Protobuf.Wire_Format.PB_String'(Value);
     end if;
  end Set_Trailing_Comments;

  function Release_Trailing_Comments
     (The_Message : in out SourceCodeInfo.Location.Instance) return Google.Protobuf.Wire_Format.PB_String_Access is
  begin
     The_Message.Clear_Has_Trailing_Comments;
     if The_Message.Trailing_Comments = Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
        return null;
     else
        declare
           Temp : Google.Protobuf.Wire_Format.PB_String_Access := The_Message.Trailing_Comments;
        begin
           The_Message.Trailing_Comments := Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access;
           return Temp;
        end;
     end if;
  end Release_Trailing_Comments;

  -- repeated string leading_detached_comments = 6;
  function Leading_Detached_Comments_Size
     (The_Message : in SourceCodeInfo.Location.Instance) return Google.Protobuf.Wire_Format.PB_Object_Size is
  begin
     return Google.Protobuf.Wire_Format.PB_Object_Size (The_Message.Leading_Detached_Comments.Length);
  end Leading_Detached_Comments_Size;

  procedure Clear_Leading_Detached_Comments
     (The_Message : in out SourceCodeInfo.Location.Instance) is
  begin
    declare
       Temp : Google.Protobuf.Wire_Format.PB_String_Access;
       procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
    begin
       for E of The_Message.Leading_Detached_Comments loop
          Temp := E;
          Free (Temp);
       end loop;
    end;
    The_Message.Leading_Detached_Comments.Clear;

  end Clear_Leading_Detached_Comments;

  function Get_Leading_Detached_Comments
     (The_Message : in SourceCodeInfo.Location.Instance;
      Index       : in Google.Protobuf.Wire_Format.PB_Object_Size) return Google.Protobuf.Wire_Format.PB_String is
  begin
     return The_Message.Leading_Detached_Comments.Element (Index).all;
  end Get_Leading_Detached_Comments;

  procedure Set_Leading_Detached_Comments
       (The_Message : in out SourceCodeInfo.Location.Instance;
        Index       : in Google.Protobuf.Wire_Format.PB_Object_Size;
        Value       : in Google.Protobuf.Wire_Format.PB_String) is
    begin
       declare
          Temp : Google.Protobuf.Wire_Format.PB_String_Access := The_Message.Leading_Detached_Comments.Element (Index);
          procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
       begin
          Free (Temp);
       end;
       The_Message.Leading_Detached_Comments.Replace_Element (Index, new Google.Protobuf.Wire_Format.PB_String'(Value));
    end Set_Leading_Detached_Comments;

    procedure Add_Leading_Detached_Comments
       (The_Message : in out SourceCodeInfo.Location.Instance;
        Value       : in Google.Protobuf.Wire_Format.PB_String) is
    begin
       The_Message.Leading_Detached_Comments.Append (new Google.Protobuf.Wire_Format.PB_String'(Value));
    end Add_Leading_Detached_Comments;

  end Google_Protobuf.SourceCodeInfo.Location;
  --  end read only
