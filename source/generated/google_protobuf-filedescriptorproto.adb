--  begin read only
--  Generated by the protocol buffer compiler. DO NOT EDIT!
--  source: google/protobuf/descriptor.proto
--
--  ----------------------------------------------------------------------
pragma Warnings (Off);
pragma Ada_2012;
with Google.Protobuf.Message;
with Google.Protobuf.Wire_Format;
with Google.Protobuf.IO.Coded_Output_Stream;
with Google.Protobuf.IO.Coded_Input_Stream;
with Google.Protobuf.Generated_Message_Utilities;
with Ada.Streams.Stream_IO;
with Ada.Containers.Vectors;
with Ada.Unchecked_Conversion;
with Ada.Unchecked_Deallocation;
with Interfaces;

with Google_Protobuf.DescriptorProto;
with Google_Protobuf.EnumDescriptorProto;
with Google_Protobuf.FieldDescriptorProto;
with Google_Protobuf.FileOptions;
with Google_Protobuf.ServiceDescriptorProto;
with Google_Protobuf.SourceCodeInfo;

package body Google_Protobuf.FileDescriptorProto is
  ---------------------------------------------------------------------------
  --    Inherited functions and procedures from Google.Protobuf.Message    --
  ---------------------------------------------------------------------------

  procedure Clear (The_Message : in out Google_Protobuf.FileDescriptorProto.Instance) is
  begin
    if (The_Message.Has_Bits (0 / 32) and Google.Protobuf.Wire_Format.Shift_Left (16#FF#, 0 mod 32)) /= 0 then
      if The_Message.Has_Name then
        The_Message.Clear_Has_Name;
        declare
           procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
        begin
           if The_Message.Name /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
              Free (The_Message.Name);
           end if;
        end;
        The_Message.Name := Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access;
      end if;
      if The_Message.Has_Package_Pb then
        The_Message.Clear_Has_Package_Pb;
        declare
           procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
        begin
           if The_Message.Package_Pb /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
              Free (The_Message.Package_Pb);
           end if;
        end;
        The_Message.Package_Pb := Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access;
      end if;
    end if;
    if (The_Message.Has_Bits (9 / 32) and Google.Protobuf.Wire_Format.Shift_Left (16#FF#, 9 mod 32)) /= 0 then
      if The_Message.Has_Options then
        The_Message.Clear_Has_Options;
        declare
           Temp : Google.Protobuf.Message.Instance_Access := Google.Protobuf.Message.Instance_Access(The_Message.Options);
        begin
           Google.Protobuf.Message.Free (Temp);
           The_Message.Options := null;
        end;
      end if;
      if The_Message.Has_Source_Code_Info then
        The_Message.Clear_Has_Source_Code_Info;
        declare
           Temp : Google.Protobuf.Message.Instance_Access := Google.Protobuf.Message.Instance_Access(The_Message.Source_Code_Info);
        begin
           Google.Protobuf.Message.Free (Temp);
           The_Message.Source_Code_Info := null;
        end;
      end if;
      if The_Message.Has_Syntax then
        The_Message.Clear_Has_Syntax;
        declare
           procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
        begin
           if The_Message.Syntax /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
              Free (The_Message.Syntax);
           end if;
        end;
        The_Message.Syntax := Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access;
      end if;
    end if;
    declare
       Temp : Google.Protobuf.Wire_Format.PB_String_Access;
       procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
    begin
       for E of The_Message.Dependency loop
          Temp := E;
          Free (Temp);
       end loop;
    end;
    The_Message.Dependency.Clear;

    The_Message.Public_Dependency.Clear;
    The_Message.Weak_Dependency.Clear;
    for C in The_Message.Message_Type.Iterate loop
       Google.Protobuf.Message.Free (The_Message.Message_Type.Reference (C).Element.all);
    end loop;
    The_Message.Message_Type.Clear;

    for C in The_Message.Enum_Type.Iterate loop
       Google.Protobuf.Message.Free (The_Message.Enum_Type.Reference (C).Element.all);
    end loop;
    The_Message.Enum_Type.Clear;

    for C in The_Message.Service.Iterate loop
       Google.Protobuf.Message.Free (The_Message.Service.Reference (C).Element.all);
    end loop;
    The_Message.Service.Clear;

    for C in The_Message.Extension.Iterate loop
       Google.Protobuf.Message.Free (The_Message.Extension.Reference (C).Element.all);
    end loop;
    The_Message.Extension.Clear;

    The_Message.Has_Bits := (others => 0);
  end Clear;

  procedure Copy (To   : in out Google_Protobuf.FileDescriptorProto.Instance;
                  From : in Google_Protobuf.FileDescriptorProto.Instance) is
  begin
     To.Clear;
     To.Merge (From);
  end Copy;

  function Get_Type_Name (The_Message : in Google_Protobuf.FileDescriptorProto.Instance) return Google.Protobuf.Wire_Format.PB_String is
  begin
     return "google.protobuf.FileDescriptorProto";
  end Get_Type_Name;

  function Is_Initialized (The_Message : in Google_Protobuf.FileDescriptorProto.Instance) return Boolean is
  begin
    for E of The_Message.Message_Type loop
       if not E.Is_Initialized then
          return False;
       end if;
    end loop;
    for E of The_Message.Enum_Type loop
       if not E.Is_Initialized then
          return False;
       end if;
    end loop;
    for E of The_Message.Service loop
       if not E.Is_Initialized then
          return False;
       end if;
    end loop;
    for E of The_Message.Extension loop
       if not E.Is_Initialized then
          return False;
       end if;
    end loop;
    if The_Message.Has_Options then
       if not The_Message.Options.Is_Initialized then
          return false;
       end if;
    end if;
    return True;
  end Is_Initialized;

  procedure Merge (To : in out Google_Protobuf.FileDescriptorProto.Instance; From : in Google_Protobuf.FileDescriptorProto.Instance) is
  begin
    for E of From.Dependency loop
       To.Dependency.Append (new Google.Protobuf.Wire_Format.PB_String'(E.all));
    end loop;
    To.Public_Dependency.Append(From.Public_Dependency);
    To.Weak_Dependency.Append(From.Weak_Dependency);
    declare
       Temp : Google_Protobuf.DescriptorProto.DescriptorProto_Access;
    begin
       for E of From.Message_Type loop
          Temp := new Google_Protobuf.DescriptorProto.Instance;
          Temp.Merge (Google_Protobuf.DescriptorProto.Instance (E.all));
          To.Message_Type.Append (Google.Protobuf.Message.Instance_Access (Temp));
       end loop;
    end;
    declare
       Temp : Google_Protobuf.EnumDescriptorProto.EnumDescriptorProto_Access;
    begin
       for E of From.Enum_Type loop
          Temp := new Google_Protobuf.EnumDescriptorProto.Instance;
          Temp.Merge (Google_Protobuf.EnumDescriptorProto.Instance (E.all));
          To.Enum_Type.Append (Google.Protobuf.Message.Instance_Access (Temp));
       end loop;
    end;
    declare
       Temp : Google_Protobuf.ServiceDescriptorProto.ServiceDescriptorProto_Access;
    begin
       for E of From.Service loop
          Temp := new Google_Protobuf.ServiceDescriptorProto.Instance;
          Temp.Merge (Google_Protobuf.ServiceDescriptorProto.Instance (E.all));
          To.Service.Append (Google.Protobuf.Message.Instance_Access (Temp));
       end loop;
    end;
    declare
       Temp : Google_Protobuf.FieldDescriptorProto.FieldDescriptorProto_Access;
    begin
       for E of From.Extension loop
          Temp := new Google_Protobuf.FieldDescriptorProto.Instance;
          Temp.Merge (Google_Protobuf.FieldDescriptorProto.Instance (E.all));
          To.Extension.Append (Google.Protobuf.Message.Instance_Access (Temp));
       end loop;
    end;
    if (From.Has_Bits (0 / 32) and Google.Protobuf.Wire_Format.Shift_Left (16#FF#, 0 mod 32)) /= 0 then
      -- optional string name = 1;
      if From.Has_Name then
        To.Set_Name(From.Get_Name);
      end if;
      -- optional string package = 2;
      if From.Has_Package_Pb then
        To.Set_Package_Pb(From.Get_Package_Pb);
      end if;
    end if;
    if (From.Has_Bits (9 / 32) and Google.Protobuf.Wire_Format.Shift_Left (16#FF#, 9 mod 32)) /= 0 then
      -- optional .google.protobuf.FileOptions options = 8;
      if From.Has_Options then
        To.Get_Options.Merge (From.Options.all);
      end if;
      -- optional .google.protobuf.SourceCodeInfo source_code_info = 9;
      if From.Has_Source_Code_Info then
        To.Get_Source_Code_Info.Merge (From.Source_Code_Info.all);
      end if;
      -- optional string syntax = 12;
      if From.Has_Syntax then
        To.Set_Syntax(From.Get_Syntax);
      end if;
    end if;
  end Merge;

  function Byte_Size (The_Message : in out Google_Protobuf.FileDescriptorProto.Instance) return Google.Protobuf.Wire_Format.PB_Object_Size is
     Total_Size : Google.Protobuf.Wire_Format.PB_Object_Size := 0;
  begin
    if (The_Message.Has_Bits (0 / 32) and Google.Protobuf.Wire_Format.Shift_Left (16#FF#, 0 mod 32)) /= 0 then
      -- optional string name = 1;
      if The_Message.Has_Name then
        Total_Size := Total_Size + 1 + Google.Protobuf.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.Name.all);
      end if;
      -- optional string package = 2;
      if The_Message.Has_Package_Pb then
        Total_Size := Total_Size + 1 + Google.Protobuf.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.Package_Pb.all);
      end if;
    end if;
    if (The_Message.Has_Bits (9 / 32) and Google.Protobuf.Wire_Format.Shift_Left (16#FF#, 9 mod 32)) /= 0 then
      -- optional .google.protobuf.FileOptions options = 8;
      if The_Message.Has_Options then
        Total_Size := Total_Size + 1 + Google.Protobuf.IO.Coded_Output_Stream.Compute_Message_Size_No_Tag (The_Message.Options.all);
      end if;
      -- optional .google.protobuf.SourceCodeInfo source_code_info = 9;
      if The_Message.Has_Source_Code_Info then
        Total_Size := Total_Size + 1 + Google.Protobuf.IO.Coded_Output_Stream.Compute_Message_Size_No_Tag (The_Message.Source_Code_Info.all);
      end if;
      -- optional string syntax = 12;
      if The_Message.Has_Syntax then
        Total_Size := Total_Size + 1 + Google.Protobuf.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (The_Message.Syntax.all);
      end if;
    end if;
    -- repeated string dependency = 3;
    Total_Size := Total_Size + 1 * The_Message.Dependency_Size;
    for E of The_Message.Dependency loop
       Total_Size := Total_Size + Google.Protobuf.IO.Coded_Output_Stream.Compute_String_Size_No_Tag (E.all);
    end loop;

    -- repeated int32 public_dependency = 10;
    declare
       Data_Size : Google.Protobuf.Wire_Format.PB_Object_Size := 0;
    begin
       for E of The_Message.Public_Dependency loop
          Data_Size := Data_Size +  Google.Protobuf.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (E);
       end loop;
       Total_Size := Total_Size + 1 * The_Message.Public_Dependency_Size + Data_Size;
    end;

    -- repeated int32 weak_dependency = 11;
    declare
       Data_Size : Google.Protobuf.Wire_Format.PB_Object_Size := 0;
    begin
       for E of The_Message.Weak_Dependency loop
          Data_Size := Data_Size +  Google.Protobuf.IO.Coded_Output_Stream.Compute_Integer_32_Size_No_Tag (E);
       end loop;
       Total_Size := Total_Size + 1 * The_Message.Weak_Dependency_Size + Data_Size;
    end;

    -- repeated .google.protobuf.DescriptorProto message_type = 4;
    Total_Size := Total_Size + 1 * The_Message.Message_Type_Size;
       for E of The_Message.Message_Type loop
       Total_Size := Total_Size + Google.Protobuf.IO.Coded_Output_Stream.Compute_Message_Size_No_Tag (E.all);
    end loop;

    -- repeated .google.protobuf.EnumDescriptorProto enum_type = 5;
    Total_Size := Total_Size + 1 * The_Message.Enum_Type_Size;
       for E of The_Message.Enum_Type loop
       Total_Size := Total_Size + Google.Protobuf.IO.Coded_Output_Stream.Compute_Message_Size_No_Tag (E.all);
    end loop;

    -- repeated .google.protobuf.ServiceDescriptorProto service = 6;
    Total_Size := Total_Size + 1 * The_Message.Service_Size;
       for E of The_Message.Service loop
       Total_Size := Total_Size + Google.Protobuf.IO.Coded_Output_Stream.Compute_Message_Size_No_Tag (E.all);
    end loop;

    -- repeated .google.protobuf.FieldDescriptorProto extension = 7;
    Total_Size := Total_Size + 1 * The_Message.Extension_Size;
       for E of The_Message.Extension loop
       Total_Size := Total_Size + Google.Protobuf.IO.Coded_Output_Stream.Compute_Message_Size_No_Tag (E.all);
    end loop;

    The_Message.Cached_Size := Total_Size;
    return Total_Size;
  end Byte_Size;

  procedure Serialize_With_Cached_Sizes
     (The_Message   : in Google_Protobuf.FileDescriptorProto.Instance;
      The_Coded_Output_Stream : in Google.Protobuf.IO.Coded_Output_Stream.Instance) is
  begin
    -- optional string name = 1;
    if The_Message.Has_Name then
      The_Coded_Output_Stream.Write_String (1, The_Message.Name.all);
    end if;
    -- optional string package = 2;
    if The_Message.Has_Package_Pb then
      The_Coded_Output_Stream.Write_String (2, The_Message.Package_Pb.all);
    end if;
    -- repeated string dependency = 3;
    for E of The_Message.Dependency loop
       The_Coded_Output_Stream.Write_String (3, E.all);
    end loop;
    -- repeated .google.protobuf.DescriptorProto message_type = 4;
    for E of The_Message.Message_Type loop
       The_Coded_Output_Stream.Write_Message (4, E.all);
    end loop;
    -- repeated .google.protobuf.EnumDescriptorProto enum_type = 5;
    for E of The_Message.Enum_Type loop
       The_Coded_Output_Stream.Write_Message (5, E.all);
    end loop;
    -- repeated .google.protobuf.ServiceDescriptorProto service = 6;
    for E of The_Message.Service loop
       The_Coded_Output_Stream.Write_Message (6, E.all);
    end loop;
    -- repeated .google.protobuf.FieldDescriptorProto extension = 7;
    for E of The_Message.Extension loop
       The_Coded_Output_Stream.Write_Message (7, E.all);
    end loop;
    -- optional .google.protobuf.FileOptions options = 8;
    if The_Message.Has_Options then
      The_Coded_Output_Stream.Write_Message (8, The_Message.Options.all);
    end if;
    -- optional .google.protobuf.SourceCodeInfo source_code_info = 9;
    if The_Message.Has_Source_Code_Info then
      The_Coded_Output_Stream.Write_Message (9, The_Message.Source_Code_Info.all);
    end if;
    -- repeated int32 public_dependency = 10;
    for E of The_Message.Public_Dependency loop
       The_Coded_Output_Stream.Write_Integer_32 (10, E);
    end loop;
    -- repeated int32 weak_dependency = 11;
    for E of The_Message.Weak_Dependency loop
       The_Coded_Output_Stream.Write_Integer_32 (11, E);
    end loop;
    -- optional string syntax = 12;
    if The_Message.Has_Syntax then
      The_Coded_Output_Stream.Write_String (12, The_Message.Syntax.all);
    end if;
  end Serialize_With_Cached_Sizes;

  procedure Merge_Partial_From_Coded_Input_Stream
     (The_Message   : in out Google_Protobuf.FileDescriptorProto.Instance;
      The_Coded_Input_Stream : in out Google.Protobuf.IO.Coded_Input_Stream.Instance) is

     Tag : Google.Protobuf.Wire_Format.PB_UInt32;
  begin
    Tag := The_Coded_Input_Stream.Read_Tag;
    while Tag /= 0 loop
      case Google.Protobuf.Wire_Format.Get_Tag_Field_Number (Tag) is
      -- optional string name = 1;
      when 1 =>
        if Google.Protobuf.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Google.Protobuf.Wire_Format.LENGTH_DELIMITED then
          declare
             procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
          begin
             if The_Message.Name /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
                Free (The_Message.Name);
             end if;
          end;
          The_Message.Set_Has_Name;
          The_Message.Name := The_Coded_Input_Stream.Read_String;
        end if;
      -- optional string package = 2;
      when 2 =>
        if Google.Protobuf.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Google.Protobuf.Wire_Format.LENGTH_DELIMITED then
          declare
             procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
          begin
             if The_Message.Package_Pb /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
                Free (The_Message.Package_Pb);
             end if;
          end;
          The_Message.Set_Has_Package_Pb;
          The_Message.Package_Pb := The_Coded_Input_Stream.Read_String;
        end if;
      -- repeated string dependency = 3;
      when 3 =>
        if Google.Protobuf.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Google.Protobuf.Wire_Format.LENGTH_DELIMITED then
          The_Message.Dependency.Append (The_Coded_Input_Stream.Read_String);
        end if;
      -- repeated .google.protobuf.DescriptorProto message_type = 4;
      when 4 =>
        if Google.Protobuf.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Google.Protobuf.Wire_Format.LENGTH_DELIMITED then
          declare
             Temp : Google_Protobuf.DescriptorProto.DescriptorProto_Access := The_Message.Add_Message_Type;
          begin
             The_Coded_Input_Stream.Read_Message (Temp.all);
          end;
        end if;
      -- repeated .google.protobuf.EnumDescriptorProto enum_type = 5;
      when 5 =>
        if Google.Protobuf.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Google.Protobuf.Wire_Format.LENGTH_DELIMITED then
          declare
             Temp : Google_Protobuf.EnumDescriptorProto.EnumDescriptorProto_Access := The_Message.Add_Enum_Type;
          begin
             The_Coded_Input_Stream.Read_Message (Temp.all);
          end;
        end if;
      -- repeated .google.protobuf.ServiceDescriptorProto service = 6;
      when 6 =>
        if Google.Protobuf.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Google.Protobuf.Wire_Format.LENGTH_DELIMITED then
          declare
             Temp : Google_Protobuf.ServiceDescriptorProto.ServiceDescriptorProto_Access := The_Message.Add_Service;
          begin
             The_Coded_Input_Stream.Read_Message (Temp.all);
          end;
        end if;
      -- repeated .google.protobuf.FieldDescriptorProto extension = 7;
      when 7 =>
        if Google.Protobuf.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Google.Protobuf.Wire_Format.LENGTH_DELIMITED then
          declare
             Temp : Google_Protobuf.FieldDescriptorProto.FieldDescriptorProto_Access := The_Message.Add_Extension;
          begin
             The_Coded_Input_Stream.Read_Message (Temp.all);
          end;
        end if;
      -- optional .google.protobuf.FileOptions options = 8;
      when 8 =>
        if Google.Protobuf.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Google.Protobuf.Wire_Format.LENGTH_DELIMITED then
          The_Coded_Input_Stream.Read_Message (The_Message.Get_Options.all);
        end if;
      -- optional .google.protobuf.SourceCodeInfo source_code_info = 9;
      when 9 =>
        if Google.Protobuf.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Google.Protobuf.Wire_Format.LENGTH_DELIMITED then
          The_Coded_Input_Stream.Read_Message (The_Message.Get_Source_Code_Info.all);
        end if;
      -- repeated int32 public_dependency = 10;
      when 10 =>
        if Google.Protobuf.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Google.Protobuf.Wire_Format.VARINT then
          The_Message.Public_Dependency.Append (The_Coded_Input_Stream.Read_Integer_32);
        end if;
      -- repeated int32 weak_dependency = 11;
      when 11 =>
        if Google.Protobuf.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Google.Protobuf.Wire_Format.VARINT then
          The_Message.Weak_Dependency.Append (The_Coded_Input_Stream.Read_Integer_32);
        end if;
      -- optional string syntax = 12;
      when 12 =>
        if Google.Protobuf.Wire_Format.Get_Tag_Wire_Type (Tag) =
          Google.Protobuf.Wire_Format.LENGTH_DELIMITED then
          declare
             procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
          begin
             if The_Message.Syntax /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
                Free (The_Message.Syntax);
             end if;
          end;
          The_Message.Set_Has_Syntax;
          The_Message.Syntax := The_Coded_Input_Stream.Read_String;
        end if;
      when others =>
        declare
           Dummy : Google.Protobuf.Wire_Format.PB_Bool with Unreferenced;
        begin
           Dummy := The_Coded_Input_Stream.Skip_Field (Tag);
           return;
        end;
      end case;
      Tag := The_Coded_Input_Stream.Read_Tag;
    end loop;
  end Merge_Partial_From_Coded_Input_Stream;

  function Get_Cached_Size
     (The_Message : in Google_Protobuf.FileDescriptorProto.Instance) return Google.Protobuf.Wire_Format.PB_Object_Size is
  begin
     return The_Message.Cached_Size;
  end Get_Cached_Size;

  overriding
  procedure Finalize (The_Message : in out Google_Protobuf.FileDescriptorProto.Instance) is
  begin
    declare
       procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
    begin
       if The_Message.Name /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.Name);
       end if;
    end;
    declare
       procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
    begin
       if The_Message.Package_Pb /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.Package_Pb);
       end if;
    end;
    declare
       Temp : Google.Protobuf.Wire_Format.PB_String_Access;
       procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
    begin
       for E of The_Message.Dependency loop
          Temp := E;
          Free (Temp);
       end loop;
    end;
    The_Message.Dependency.Clear;

    for C in The_Message.Message_Type.Iterate loop
       Google.Protobuf.Message.Free (The_Message.Message_Type.Reference (C).Element.all);
    end loop;
    The_Message.Message_Type.Clear;

    for C in The_Message.Enum_Type.Iterate loop
       Google.Protobuf.Message.Free (The_Message.Enum_Type.Reference (C).Element.all);
    end loop;
    The_Message.Enum_Type.Clear;

    for C in The_Message.Service.Iterate loop
       Google.Protobuf.Message.Free (The_Message.Service.Reference (C).Element.all);
    end loop;
    The_Message.Service.Clear;

    for C in The_Message.Extension.Iterate loop
       Google.Protobuf.Message.Free (The_Message.Extension.Reference (C).Element.all);
    end loop;
    The_Message.Extension.Clear;

    declare
       Temp : Google.Protobuf.Message.Instance_Access := Google.Protobuf.Message.Instance_Access(The_Message.Options);
    begin
       Google.Protobuf.Message.Free (Temp);
       The_Message.Options := null;
    end;
    declare
       Temp : Google.Protobuf.Message.Instance_Access := Google.Protobuf.Message.Instance_Access(The_Message.Source_Code_Info);
    begin
       Google.Protobuf.Message.Free (Temp);
       The_Message.Source_Code_Info := null;
    end;
    declare
       procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
    begin
       if The_Message.Syntax /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.Syntax);
       end if;
    end;
  end Finalize;

  ---------------------------------------------------------------------------
  --                  Field accessor definitions                           --
  ---------------------------------------------------------------------------

  -- optional string name = 1;
  function Has_Name
     (The_Message : in FileDescriptorProto.Instance) return Boolean is
  begin
     return (The_Message.Has_Bits(0) and 16#00000001#) /= 0;
  end Has_Name;

  procedure Set_Has_Name
     (The_Message : in out FileDescriptorProto.Instance) is
  begin
     The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000001#;
  end Set_Has_Name;

  procedure Clear_Has_Name
     (The_Message : in out FileDescriptorProto.Instance) is
  begin
     The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000001#);
  end Clear_Has_Name;

  procedure Clear_Name
     (The_Message : in out FileDescriptorProto.Instance) is
  begin
    The_Message.Clear_Has_Name;
    declare
       procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
    begin
       if The_Message.Name /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.Name);
       end if;
    end;
    The_Message.Name := Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access;
    The_Message.Clear_Has_Name;
  end Clear_Name;

  function Get_Name
     (The_Message : in FileDescriptorProto.Instance) return Google.Protobuf.Wire_Format.PB_String is
  begin
     return The_Message.Name.all;
  end Get_Name;

  function Get_Name
     (The_Message : in out FileDescriptorProto.Instance;
     Size        : in Integer := -1) return Google.Protobuf.Wire_Format.PB_String_Access is
  begin
     The_Message.Set_Has_Name;
     if Size >= 0 then
  declare
     procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
  begin
     if The_Message.Name /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
        Free (The_Message.Name);
     end if;
  end;
         The_Message.Name := new Google.Protobuf.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
         return The_Message.Name;
     end if;

     if The_Message.Name = Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
        The_Message.Name := new String'(Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING);
      end if;
      return The_Message.Name;
  end Get_Name;

  procedure Set_Name
     (The_Message : in out FileDescriptorProto.Instance;
      Value       : in Google.Protobuf.Wire_Format.PB_String) is
  begin
     The_Message.Set_Has_Name;
     if The_Message.Name /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access and then Value'Length = The_Message.Name.all'Length then
        The_Message.Name.all := Value;
     else
  declare
     procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
  begin
     if The_Message.Name /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
        Free (The_Message.Name);
     end if;
  end;
        The_Message.Name := new Google.Protobuf.Wire_Format.PB_String'(Value);
     end if;
  end Set_Name;

  function Release_Name
     (The_Message : in out FileDescriptorProto.Instance) return Google.Protobuf.Wire_Format.PB_String_Access is
  begin
     The_Message.Clear_Has_Name;
     if The_Message.Name = Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
        return null;
     else
        declare
           Temp : Google.Protobuf.Wire_Format.PB_String_Access := The_Message.Name;
        begin
           The_Message.Name := Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access;
           return Temp;
        end;
     end if;
  end Release_Name;

  -- optional string package = 2;
  function Has_Package_Pb
     (The_Message : in FileDescriptorProto.Instance) return Boolean is
  begin
     return (The_Message.Has_Bits(0) and 16#00000002#) /= 0;
  end Has_Package_Pb;

  procedure Set_Has_Package_Pb
     (The_Message : in out FileDescriptorProto.Instance) is
  begin
     The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000002#;
  end Set_Has_Package_Pb;

  procedure Clear_Has_Package_Pb
     (The_Message : in out FileDescriptorProto.Instance) is
  begin
     The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000002#);
  end Clear_Has_Package_Pb;

  procedure Clear_Package_Pb
     (The_Message : in out FileDescriptorProto.Instance) is
  begin
    The_Message.Clear_Has_Package_Pb;
    declare
       procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
    begin
       if The_Message.Package_Pb /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.Package_Pb);
       end if;
    end;
    The_Message.Package_Pb := Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access;
    The_Message.Clear_Has_Package_Pb;
  end Clear_Package_Pb;

  function Get_Package_Pb
     (The_Message : in FileDescriptorProto.Instance) return Google.Protobuf.Wire_Format.PB_String is
  begin
     return The_Message.Package_Pb.all;
  end Get_Package_Pb;

  function Get_Package_Pb
     (The_Message : in out FileDescriptorProto.Instance;
     Size        : in Integer := -1) return Google.Protobuf.Wire_Format.PB_String_Access is
  begin
     The_Message.Set_Has_Package_Pb;
     if Size >= 0 then
  declare
     procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
  begin
     if The_Message.Package_Pb /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
        Free (The_Message.Package_Pb);
     end if;
  end;
         The_Message.Package_Pb := new Google.Protobuf.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
         return The_Message.Package_Pb;
     end if;

     if The_Message.Package_Pb = Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
        The_Message.Package_Pb := new String'(Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING);
      end if;
      return The_Message.Package_Pb;
  end Get_Package_Pb;

  procedure Set_Package_Pb
     (The_Message : in out FileDescriptorProto.Instance;
      Value       : in Google.Protobuf.Wire_Format.PB_String) is
  begin
     The_Message.Set_Has_Package_Pb;
     if The_Message.Package_Pb /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access and then Value'Length = The_Message.Package_Pb.all'Length then
        The_Message.Package_Pb.all := Value;
     else
  declare
     procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
  begin
     if The_Message.Package_Pb /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
        Free (The_Message.Package_Pb);
     end if;
  end;
        The_Message.Package_Pb := new Google.Protobuf.Wire_Format.PB_String'(Value);
     end if;
  end Set_Package_Pb;

  function Release_Package_Pb
     (The_Message : in out FileDescriptorProto.Instance) return Google.Protobuf.Wire_Format.PB_String_Access is
  begin
     The_Message.Clear_Has_Package_Pb;
     if The_Message.Package_Pb = Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
        return null;
     else
        declare
           Temp : Google.Protobuf.Wire_Format.PB_String_Access := The_Message.Package_Pb;
        begin
           The_Message.Package_Pb := Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access;
           return Temp;
        end;
     end if;
  end Release_Package_Pb;

  -- repeated string dependency = 3;
  function Dependency_Size
     (The_Message : in FileDescriptorProto.Instance) return Google.Protobuf.Wire_Format.PB_Object_Size is
  begin
     return Google.Protobuf.Wire_Format.PB_Object_Size (The_Message.Dependency.Length);
  end Dependency_Size;

  procedure Clear_Dependency
     (The_Message : in out FileDescriptorProto.Instance) is
  begin
    declare
       Temp : Google.Protobuf.Wire_Format.PB_String_Access;
       procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
    begin
       for E of The_Message.Dependency loop
          Temp := E;
          Free (Temp);
       end loop;
    end;
    The_Message.Dependency.Clear;

  end Clear_Dependency;

  function Get_Dependency
     (The_Message : in FileDescriptorProto.Instance;
      Index       : in Google.Protobuf.Wire_Format.PB_Object_Size) return Google.Protobuf.Wire_Format.PB_String is
  begin
     return The_Message.Dependency.Element (Index).all;
  end Get_Dependency;

  procedure Set_Dependency
       (The_Message : in out FileDescriptorProto.Instance;
        Index       : in Google.Protobuf.Wire_Format.PB_Object_Size;
        Value       : in Google.Protobuf.Wire_Format.PB_String) is
    begin
       declare
          Temp : Google.Protobuf.Wire_Format.PB_String_Access := The_Message.Dependency.Element (Index);
          procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
       begin
          Free (Temp);
       end;
       The_Message.Dependency.Replace_Element (Index, new Google.Protobuf.Wire_Format.PB_String'(Value));
    end Set_Dependency;

    procedure Add_Dependency
       (The_Message : in out FileDescriptorProto.Instance;
        Value       : in Google.Protobuf.Wire_Format.PB_String) is
    begin
       The_Message.Dependency.Append (new Google.Protobuf.Wire_Format.PB_String'(Value));
    end Add_Dependency;

    -- repeated int32 public_dependency = 10;
    function Public_Dependency_Size
       (The_Message : in FileDescriptorProto.Instance) return Google.Protobuf.Wire_Format.PB_Object_Size is
    begin
       return Google.Protobuf.Wire_Format.PB_Object_Size (The_Message.Public_Dependency.Length);
    end Public_Dependency_Size;

    procedure Clear_Public_Dependency
       (The_Message : in out FileDescriptorProto.Instance) is
    begin
      The_Message.Public_Dependency.Clear;
    end Clear_Public_Dependency;

    function Get_Public_Dependency
       (The_Message : in FileDescriptorProto.Instance;
        Index       : in Google.Protobuf.Wire_Format.PB_Object_Size) return Google.Protobuf.Wire_Format.PB_Int32 is
    begin
       return The_Message.Public_Dependency.Element (Index);
    end Get_Public_Dependency;

    procedure Set_Public_Dependency
       (The_Message : in out FileDescriptorProto.Instance;
        Index       : in Google.Protobuf.Wire_Format.PB_Object_Size;
        Value       : in Google.Protobuf.Wire_Format.PB_Int32) is
    begin
       The_Message.Public_Dependency.Replace_Element (Index, Value);
    end Set_Public_Dependency;

    procedure Add_Public_Dependency
       (The_Message : in out FileDescriptorProto.Instance;
        Value       : in Google.Protobuf.Wire_Format.PB_Int32) is
    begin
       The_Message.Public_Dependency.Append (Value);
    end Add_Public_Dependency;

    -- repeated int32 weak_dependency = 11;
    function Weak_Dependency_Size
       (The_Message : in FileDescriptorProto.Instance) return Google.Protobuf.Wire_Format.PB_Object_Size is
    begin
       return Google.Protobuf.Wire_Format.PB_Object_Size (The_Message.Weak_Dependency.Length);
    end Weak_Dependency_Size;

    procedure Clear_Weak_Dependency
       (The_Message : in out FileDescriptorProto.Instance) is
    begin
      The_Message.Weak_Dependency.Clear;
    end Clear_Weak_Dependency;

    function Get_Weak_Dependency
       (The_Message : in FileDescriptorProto.Instance;
        Index       : in Google.Protobuf.Wire_Format.PB_Object_Size) return Google.Protobuf.Wire_Format.PB_Int32 is
    begin
       return The_Message.Weak_Dependency.Element (Index);
    end Get_Weak_Dependency;

    procedure Set_Weak_Dependency
       (The_Message : in out FileDescriptorProto.Instance;
        Index       : in Google.Protobuf.Wire_Format.PB_Object_Size;
        Value       : in Google.Protobuf.Wire_Format.PB_Int32) is
    begin
       The_Message.Weak_Dependency.Replace_Element (Index, Value);
    end Set_Weak_Dependency;

    procedure Add_Weak_Dependency
       (The_Message : in out FileDescriptorProto.Instance;
        Value       : in Google.Protobuf.Wire_Format.PB_Int32) is
    begin
       The_Message.Weak_Dependency.Append (Value);
    end Add_Weak_Dependency;

    -- repeated .google.protobuf.DescriptorProto message_type = 4;
    function Message_Type_Size
       (The_Message : in FileDescriptorProto.Instance) return Google.Protobuf.Wire_Format.PB_Object_Size is
    begin
       return Google.Protobuf.Wire_Format.PB_Object_Size (The_Message.Message_Type.Length);
    end Message_Type_Size;

    procedure Clear_Message_Type
       (The_Message : in out FileDescriptorProto.Instance) is
    begin
      for C in The_Message.Message_Type.Iterate loop
         Google.Protobuf.Message.Free (The_Message.Message_Type.Reference (C).Element.all);
      end loop;
      The_Message.Message_Type.Clear;

    end Clear_Message_Type;

    function Get_Message_Type
       (The_Message : in FileDescriptorProto.Instance;
       Index        : in Google.Protobuf.Wire_Format.PB_Object_Size) return access Google_Protobuf.DescriptorProto.Instance is
    begin
       return Google_Protobuf.DescriptorProto.DescriptorProto_Access (The_Message.Message_Type.Element (Index));
    end Get_Message_Type;

    function Add_Message_Type
       (The_Message : in out FileDescriptorProto.Instance) return access Google_Protobuf.DescriptorProto.Instance is
       Temp : Google_Protobuf.DescriptorProto.DescriptorProto_Access := new Google_Protobuf.DescriptorProto.Instance;
    begin
       The_Message.Message_Type.Append (Google.Protobuf.Message.Instance_Access (Temp));
       return Temp;
    end Add_Message_Type;

    -- repeated .google.protobuf.EnumDescriptorProto enum_type = 5;
    function Enum_Type_Size
       (The_Message : in FileDescriptorProto.Instance) return Google.Protobuf.Wire_Format.PB_Object_Size is
    begin
       return Google.Protobuf.Wire_Format.PB_Object_Size (The_Message.Enum_Type.Length);
    end Enum_Type_Size;

    procedure Clear_Enum_Type
       (The_Message : in out FileDescriptorProto.Instance) is
    begin
      for C in The_Message.Enum_Type.Iterate loop
         Google.Protobuf.Message.Free (The_Message.Enum_Type.Reference (C).Element.all);
      end loop;
      The_Message.Enum_Type.Clear;

    end Clear_Enum_Type;

    function Get_Enum_Type
       (The_Message : in FileDescriptorProto.Instance;
       Index        : in Google.Protobuf.Wire_Format.PB_Object_Size) return access Google_Protobuf.EnumDescriptorProto.Instance is
    begin
       return Google_Protobuf.EnumDescriptorProto.EnumDescriptorProto_Access (The_Message.Enum_Type.Element (Index));
    end Get_Enum_Type;

    function Add_Enum_Type
       (The_Message : in out FileDescriptorProto.Instance) return access Google_Protobuf.EnumDescriptorProto.Instance is
       Temp : Google_Protobuf.EnumDescriptorProto.EnumDescriptorProto_Access := new Google_Protobuf.EnumDescriptorProto.Instance;
    begin
       The_Message.Enum_Type.Append (Google.Protobuf.Message.Instance_Access (Temp));
       return Temp;
    end Add_Enum_Type;

    -- repeated .google.protobuf.ServiceDescriptorProto service = 6;
    function Service_Size
       (The_Message : in FileDescriptorProto.Instance) return Google.Protobuf.Wire_Format.PB_Object_Size is
    begin
       return Google.Protobuf.Wire_Format.PB_Object_Size (The_Message.Service.Length);
    end Service_Size;

    procedure Clear_Service
       (The_Message : in out FileDescriptorProto.Instance) is
    begin
      for C in The_Message.Service.Iterate loop
         Google.Protobuf.Message.Free (The_Message.Service.Reference (C).Element.all);
      end loop;
      The_Message.Service.Clear;

    end Clear_Service;

    function Get_Service
       (The_Message : in FileDescriptorProto.Instance;
       Index        : in Google.Protobuf.Wire_Format.PB_Object_Size) return access Google_Protobuf.ServiceDescriptorProto.Instance is
    begin
       return Google_Protobuf.ServiceDescriptorProto.ServiceDescriptorProto_Access (The_Message.Service.Element (Index));
    end Get_Service;

    function Add_Service
       (The_Message : in out FileDescriptorProto.Instance) return access Google_Protobuf.ServiceDescriptorProto.Instance is
       Temp : Google_Protobuf.ServiceDescriptorProto.ServiceDescriptorProto_Access := new Google_Protobuf.ServiceDescriptorProto.Instance;
    begin
       The_Message.Service.Append (Google.Protobuf.Message.Instance_Access (Temp));
       return Temp;
    end Add_Service;

    -- repeated .google.protobuf.FieldDescriptorProto extension = 7;
    function Extension_Size
       (The_Message : in FileDescriptorProto.Instance) return Google.Protobuf.Wire_Format.PB_Object_Size is
    begin
       return Google.Protobuf.Wire_Format.PB_Object_Size (The_Message.Extension.Length);
    end Extension_Size;

    procedure Clear_Extension
       (The_Message : in out FileDescriptorProto.Instance) is
    begin
      for C in The_Message.Extension.Iterate loop
         Google.Protobuf.Message.Free (The_Message.Extension.Reference (C).Element.all);
      end loop;
      The_Message.Extension.Clear;

    end Clear_Extension;

    function Get_Extension
       (The_Message : in FileDescriptorProto.Instance;
       Index        : in Google.Protobuf.Wire_Format.PB_Object_Size) return access Google_Protobuf.FieldDescriptorProto.Instance is
    begin
       return Google_Protobuf.FieldDescriptorProto.FieldDescriptorProto_Access (The_Message.Extension.Element (Index));
    end Get_Extension;

    function Add_Extension
       (The_Message : in out FileDescriptorProto.Instance) return access Google_Protobuf.FieldDescriptorProto.Instance is
       Temp : Google_Protobuf.FieldDescriptorProto.FieldDescriptorProto_Access := new Google_Protobuf.FieldDescriptorProto.Instance;
    begin
       The_Message.Extension.Append (Google.Protobuf.Message.Instance_Access (Temp));
       return Temp;
    end Add_Extension;

    -- optional .google.protobuf.FileOptions options = 8;
    function Has_Options
       (The_Message : in FileDescriptorProto.Instance) return Boolean is
    begin
       return (The_Message.Has_Bits(0) and 16#00000200#) /= 0;
    end Has_Options;

    procedure Set_Has_Options
       (The_Message : in out FileDescriptorProto.Instance) is
    begin
       The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000200#;
    end Set_Has_Options;

    procedure Clear_Has_Options
       (The_Message : in out FileDescriptorProto.Instance) is
    begin
       The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000200#);
    end Clear_Has_Options;

    procedure Clear_Options
       (The_Message : in out FileDescriptorProto.Instance) is
    begin
      The_Message.Clear_Has_Options;
      declare
         Temp : Google.Protobuf.Message.Instance_Access := Google.Protobuf.Message.Instance_Access(The_Message.Options);
      begin
         Google.Protobuf.Message.Free (Temp);
         The_Message.Options := null;
      end;
      The_Message.Clear_Has_Options;
    end Clear_Options;

    function Get_Options (The_Message : in out FileDescriptorProto.Instance) return access Google_Protobuf.FileOptions.Instance is
       use type Google_Protobuf.FileOptions.FileOptions_Access;
    begin
       The_Message.Set_Has_Options;
       if The_Message.Options = null then
          The_Message.Options := Google_Protobuf.FileOptions.FileOptions_Access'(new Google_Protobuf.FileOptions.Instance);
       end if;
       return The_Message.Options;
    end Get_Options;

    function Release_Options (The_Message : in out FileDescriptorProto.Instance) return access Google_Protobuf.FileOptions.Instance is
       Temp : access Google_Protobuf.FileOptions.Instance;
    begin
       The_Message.Clear_Has_Options;
       Temp := The_Message.Options;
       The_Message.Options := null;
       return Temp;
    end Release_Options;

    procedure Set_Options
       (The_Message : in out FileDescriptorProto.Instance;
        Value       : in Google_Protobuf.FileOptions.FileOptions_Access) is
       use type Google_Protobuf.FileOptions.FileOptions_Access;
       Temp : Google.Protobuf.Message.Instance_Access := Google.Protobuf.Message.Instance_Access (The_Message.Options);
    begin
       Google.Protobuf.Message.Free (Temp);
       The_Message.Options := Value;
       if The_Message.Options /= null then
          The_Message.Set_Has_Options;
       else
          The_Message.Clear_Has_Options;
       end if;
    end Set_Options;

    -- optional .google.protobuf.SourceCodeInfo source_code_info = 9;
    function Has_Source_Code_Info
       (The_Message : in FileDescriptorProto.Instance) return Boolean is
    begin
       return (The_Message.Has_Bits(0) and 16#00000400#) /= 0;
    end Has_Source_Code_Info;

    procedure Set_Has_Source_Code_Info
       (The_Message : in out FileDescriptorProto.Instance) is
    begin
       The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000400#;
    end Set_Has_Source_Code_Info;

    procedure Clear_Has_Source_Code_Info
       (The_Message : in out FileDescriptorProto.Instance) is
    begin
       The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000400#);
    end Clear_Has_Source_Code_Info;

    procedure Clear_Source_Code_Info
       (The_Message : in out FileDescriptorProto.Instance) is
    begin
      The_Message.Clear_Has_Source_Code_Info;
      declare
         Temp : Google.Protobuf.Message.Instance_Access := Google.Protobuf.Message.Instance_Access(The_Message.Source_Code_Info);
      begin
         Google.Protobuf.Message.Free (Temp);
         The_Message.Source_Code_Info := null;
      end;
      The_Message.Clear_Has_Source_Code_Info;
    end Clear_Source_Code_Info;

    function Get_Source_Code_Info (The_Message : in out FileDescriptorProto.Instance) return access Google_Protobuf.SourceCodeInfo.Instance is
       use type Google_Protobuf.SourceCodeInfo.SourceCodeInfo_Access;
    begin
       The_Message.Set_Has_Source_Code_Info;
       if The_Message.Source_Code_Info = null then
          The_Message.Source_Code_Info := Google_Protobuf.SourceCodeInfo.SourceCodeInfo_Access'(new Google_Protobuf.SourceCodeInfo.Instance);
       end if;
       return The_Message.Source_Code_Info;
    end Get_Source_Code_Info;

    function Release_Source_Code_Info (The_Message : in out FileDescriptorProto.Instance) return access Google_Protobuf.SourceCodeInfo.Instance is
       Temp : access Google_Protobuf.SourceCodeInfo.Instance;
    begin
       The_Message.Clear_Has_Source_Code_Info;
       Temp := The_Message.Source_Code_Info;
       The_Message.Source_Code_Info := null;
       return Temp;
    end Release_Source_Code_Info;

    procedure Set_Source_Code_Info
       (The_Message : in out FileDescriptorProto.Instance;
        Value       : in Google_Protobuf.SourceCodeInfo.SourceCodeInfo_Access) is
       use type Google_Protobuf.SourceCodeInfo.SourceCodeInfo_Access;
       Temp : Google.Protobuf.Message.Instance_Access := Google.Protobuf.Message.Instance_Access (The_Message.Source_Code_Info);
    begin
       Google.Protobuf.Message.Free (Temp);
       The_Message.Source_Code_Info := Value;
       if The_Message.Source_Code_Info /= null then
          The_Message.Set_Has_Source_Code_Info;
       else
          The_Message.Clear_Has_Source_Code_Info;
       end if;
    end Set_Source_Code_Info;

    -- optional string syntax = 12;
    function Has_Syntax
       (The_Message : in FileDescriptorProto.Instance) return Boolean is
    begin
       return (The_Message.Has_Bits(0) and 16#00000800#) /= 0;
    end Has_Syntax;

    procedure Set_Has_Syntax
       (The_Message : in out FileDescriptorProto.Instance) is
    begin
       The_Message.Has_Bits(0) := The_Message.Has_Bits(0) or 16#00000800#;
    end Set_Has_Syntax;

    procedure Clear_Has_Syntax
       (The_Message : in out FileDescriptorProto.Instance) is
    begin
       The_Message.Has_Bits(0) := The_Message.Has_Bits(0) and (not 16#00000800#);
    end Clear_Has_Syntax;

    procedure Clear_Syntax
       (The_Message : in out FileDescriptorProto.Instance) is
    begin
      The_Message.Clear_Has_Syntax;
      declare
         procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
      begin
         if The_Message.Syntax /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
            Free (The_Message.Syntax);
         end if;
      end;
      The_Message.Syntax := Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access;
      The_Message.Clear_Has_Syntax;
    end Clear_Syntax;

    function Get_Syntax
       (The_Message : in FileDescriptorProto.Instance) return Google.Protobuf.Wire_Format.PB_String is
    begin
       return The_Message.Syntax.all;
    end Get_Syntax;

    function Get_Syntax
       (The_Message : in out FileDescriptorProto.Instance;
       Size        : in Integer := -1) return Google.Protobuf.Wire_Format.PB_String_Access is
    begin
       The_Message.Set_Has_Syntax;
       if Size >= 0 then
    declare
       procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
    begin
       if The_Message.Syntax /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.Syntax);
       end if;
    end;
           The_Message.Syntax := new Google.Protobuf.Wire_Format.PB_String'(1 .. Size => Character'Val (0));
           return The_Message.Syntax;
       end if;

       if The_Message.Syntax = Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
          The_Message.Syntax := new String'(Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING);
        end if;
        return The_Message.Syntax;
    end Get_Syntax;

    procedure Set_Syntax
       (The_Message : in out FileDescriptorProto.Instance;
        Value       : in Google.Protobuf.Wire_Format.PB_String) is
    begin
       The_Message.Set_Has_Syntax;
       if The_Message.Syntax /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access and then Value'Length = The_Message.Syntax.all'Length then
          The_Message.Syntax.all := Value;
       else
    declare
       procedure Free is new Ada.Unchecked_Deallocation (Google.Protobuf.Wire_Format.PB_String, Google.Protobuf.Wire_Format.PB_String_Access);
    begin
       if The_Message.Syntax /= Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
          Free (The_Message.Syntax);
       end if;
    end;
          The_Message.Syntax := new Google.Protobuf.Wire_Format.PB_String'(Value);
       end if;
    end Set_Syntax;

    function Release_Syntax
       (The_Message : in out FileDescriptorProto.Instance) return Google.Protobuf.Wire_Format.PB_String_Access is
    begin
       The_Message.Clear_Has_Syntax;
       if The_Message.Syntax = Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access then
          return null;
       else
          declare
             Temp : Google.Protobuf.Wire_Format.PB_String_Access := The_Message.Syntax;
          begin
             The_Message.Syntax := Google.Protobuf.Generated_Message_Utilities.EMPTY_STRING'Access;
             return Temp;
          end;
       end if;
    end Release_Syntax;

  end Google_Protobuf.FileDescriptorProto;
  --  end read only
